## 建造者模式（又叫生成器模式）
### 传统方式解法
* 简单易操作）和创建产品的过程（建房子流程）封装在一起，耦合性增强
       ### 建造者模式
       #### 四个角色
       * Product(产品角色)：该角色是建造的复杂对象，提供基本方法
       * Builder(抽象建造者)：负责调用具体建造者按照顺序建造产品。导演者只负责调度，真正执行的是具体建造者角色。
       * ConcreteBuilder（具体建造者）：该角色实现了抽象建造者抽象建造者接口，主要是实现所有声明的方法以及返回建造好的产品实例。
       * Director(指挥者)：负责调用具体建造者按照顺序建造产品。导演者只负责调度，真正执行的是具体建造者角色。
* 将产品（房子）和创建产品的过程（建房子流程）封装在一起，耦合性增强
### 建造者模式
#### 四个角色
* Product(产品角色)：该角色是建造的复杂对象，提供基本方法
* Builder(抽象建造者)：负责调用具体建造者按照顺序建造产品。导演者只负责调度，真正执行的是具体建造者角色。
* ConcreteBuilder（具体建造者）：该角色实现了抽象建造者抽象建造者接口，主要是实现所有声明的方法以及返回建造好的产品实例。
* Director(指挥者)：负责调用具体建造者按照顺序建造产品。导演者只负责调度，真正执行的是具体建造者角色。
#### 注意事项和细节
* 客户端不知道产品内部组成细节，将产品本身与创建过程结偶，使的相同的创建过程可以创建不同的产品对象
* 每一个建造者都是相对独立的，可以替换新增建造者得到不同的产品
* 可以更加精细的控制产品的创建过程
* 增加新的建造者不用修改原建造者复合开闭原则
* 建造的产品一般具有较多的共同特点，否则不实用建造模式
* 如果产品内部变化复杂，可能会导致需要定义更多的具体建造者，则不实用此模式
#### 建造者 VS 抽象工厂模式
* 抽象工厂模式实现对产品家族的创建，一个产品家族是这样一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关系构建过程，只关系什么产品由什么工厂生产即可
* 而建造者模式需要按照蓝图建造产品，它的主要目的是通过组装零配件而产生一个新的产品